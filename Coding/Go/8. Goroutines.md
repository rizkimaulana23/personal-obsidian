Goroutines digunakan untuk menjalankan function secara bersamaan dan nantinya akan dieksekusi bersama-sama (concurrently).

concurrency != parallel executions

```go
var dbData = []string{"id1", "id2", "id3", "id4", "id5"}

func main() {
    t0 := time.Now()
    for i := 0; i < len(dbData); i++ {
        dbCall(i)
    }
    fmt.Printf("\nTotal execution time: %v", time.Since(t0))
}

func dbCall(i int) {
    var delay float32 = rand.Float32() * 2000
    time.Sleep(time.Duration(delay) * time.Millisecond)
    fmt.Println("The result from the database is:", dbData[i])
}
```

```
The result from the database is: id1
The result from the database is: id2
The result from the database is: id3
The result from the database is: id4
The result from the database is: id5

Total execution time: 3.5136199s
```
Jika menggunakan code tersebut, kita akan memanggil dan menunggu dbCall hingga selesai dulu, baru melanjutkan melakukan panggilan selanjutnya.
## Wait Group
Untuk melakukan concurrency, kita dapa menggunakan Wait Group. Wait Group disini sama dengan seperti counter
- Add(n) akan menambahkan jumlah counter sebanyak n
- wg.Done() akan mengurangi counter sebanyak 1
- wg.Wait() akan menunggu hingga counter menjadi 0 baru mengeksekusi bagian code selanjutnya.
```go
import (
    "fmt"
    "math/rand"
    "sync"
    "time"
)

var wg = sync.WaitGroup{}
var dbData = []string{"id1", "id2", "id3", "id4", "id5"}

func main() {
    t0 := time.Now()
    for i := 0; i < len(dbData); i++ {
        wg.Add(1)
        go dbCall(i)
    }
    wg.Wait()
    fmt.Printf("\nTotal execution time: %v", time.Since(t0))
}

func dbCall(i int) {
    var delay float32 = rand.Float32() * 2000
    time.Sleep(time.Duration(delay) * time.Millisecond)
    fmt.Println("The result from the database is:", dbData[i])
    wg.Done()
}
```

```go
The result from the database is: id3
The result from the database is: id1
The result from the database is: id4
The result from the database is: id2
The result from the database is: id5

Total execution time: 1.4163359s
```
## Mutex (Mutual Exclusion)
Ketika beberapa concurrency execution dijalankan dan ingin melakukan write pada suatu object pada waktu yang sama, bisa saja terjadi kesalahan yang tidak terduga (data hilang, error). Oleh karena itu, gunakan mutex untuk memberhentikan execution yang lain dan fokus untuk satu execution terlebih dahulu. 
```go
import (
    "fmt"
    "sync"
    "time"
)

var m = sync.Mutex{}
var wg = sync.WaitGroup{}
var dbData = []string{"id1", "id2", "id3", "id4", "id5"}
var results = []string{}
  
func main() {
    t0 := time.Now()
    for i := 0; i < len(dbData); i++ {
        wg.Add(1)
        go dbCall(i)
    }
    wg.Wait()
    fmt.Printf("\nTotal execution time: %v", time.Since(t0))
    fmt.Println()
    fmt.Println(results)
}

func dbCall(i int) {
    var delay float32 = 2000
    time.Sleep(time.Duration(delay) * time.Millisecond)
    fmt.Println("The result from the database is:", dbData[i])
    m.Lock()
    results = append(results, dbData[i])
    m.Unlock()
    wg.Done()
}
```

