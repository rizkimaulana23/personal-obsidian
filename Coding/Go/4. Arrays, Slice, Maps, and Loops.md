## Arrays
- Fixed length
- Same type
- Indexable
- Contiguous in Memory

```go
var intArr [3]int32 
```
Panjang dari Array tersebut adalah 3. Panjang dari Arrays tidak bisa diganti setelah di-initialyze.
Default value dari Array tersebut adalah default value dari type yang digunakan. Dalam array tersebut, berarti valuenya adalah [0, 0, 0].

Karena int32 menggunkana 4 bytes memory dan panjang dari Array tersebut adalah 3, maka system akan mengalokasikan 12 bytes untuk Array tersebut secara contiguous (bersampingan). 

### Index
```go
fmt.Println(intArr[0]) // Mengakses elemen pertama
fmt.Println(intArr[1:3]) // Mengakses index elemen 1 dan 2
intArr[1] = 123
```
### Memory Location
```go
fmt.Println(&intArr[0])
fmt.Println(&intArr[1])
fmt.Println(&intArr[2])
```
### Explicitly Initializing
```go
var intArr2 [3]int32 = [3]int32{1, 2, 3}
intArr3 := [3]int32{1, 2, 3}
intArr4 := [...]int32{1, 2, 3} // Panjangnya akan sesuai dengan panjang dari banyaknya value dari {}
```
## Slice
"Slices wrap arrays to give a more general, powerful, and convenient interface to sequences of data". Arrays with additional functionality.
![[Pasted image 20250619110137.png]]
Kita dapat menggunakan function `append()` untuk menambahkan data pada suatu slice.
```go
var intSlice []int32 = []int32{4, 5, 6}
fmt.Println(intSlice)
fmt.Printf("The length is %v with capacity %v\n", len(intSlice), cap(intSlice))

intSlice = append(intSlice, 7)
fmt.Println(intSlice)
fmt.Printf("The length is %v with capacity %v", len(intSlice), cap(intSlice))
```

Hasilnya akan menjadi seperti ini:
```
[4 5 6]
The length is 3 with capacity 3
[4 5 6 7]
The length is 4 with capacity 6
```

Misalkan slice sudah penuh dan kita ingin menambahkan value baru dengan menggunakan append, maka slice tersebut akan menambahkan capacity nya berdasarkan panjang Array sebelumnya.
Misal, panjang array adalah 3 dan sudah penuh, jika di-append, capacity akan berubah menjadi 6 (3 + 3). 

### Append Multiple Value
```go
var intSlice2 []int32 = []int32{8, 9}
intSlice = append(intSlice, intSlice2...)
fmt.Println(intSlice)
```
### Explicitly Declaring the Capacity
Parameter yang pertama adalah tipe datanya, kedua adalah panjangnya, dan ketiga adalah capacity-nya. 
```go
var intSlice3 []int32 = make([]int32, 3, 8)
```
## Map
Map berisikan key :  value pair. 
```go
var myMap map[string]uint8 = make(map[string]uint8)

var myMap2 = map[string]uint8{}

myMap2["Adam"] = 1
fmt.Println(myMap2["Jason"]) // Akan mengeluarkan default value dari tipe data value-nya
```

Map akan selalu memberikan value walaupun index key nya tidak ada. Kita bisa menggunakan checking terlebih dahulu.
```go
var age, ok = myMap2["Jason"]
```
Variable `ok` tersebut akan menerima boolean. Jika `false` , maka tidak ada Index tersebut dalam map tersebut.

Untuk menghapus map, gunakan function `delete`.
```go
delete(myMap2, "Adam") // Tidak memberikan return value
```
## Loops
Saat melakukan loop pada map, urutannya tidak disimpan. Jadi, urutannya bisa random. 

Jika loop Array
```go
for name:= range myMap2 {
	fmt.Printf("Name: %v \n", name)
}

for name, age := range myMap2 {
	fmt.Printf("Name: %v \n", name)
}

for i, v := range intArr {
	fmt.Printf("Index: %v, Value: %v \n", i, v)
} // i adalah index dan v adalah value 

for i := 0; i<10:i++ {
	fmt.Println(i)
}
```