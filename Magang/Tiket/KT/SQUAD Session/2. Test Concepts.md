## Verification and Validation
Verification focuses on building the product right meanwhile Validation focuses on building the right product for the user. There are types of test for each of verification and validation.

![[Pasted image 20250715131912.png]]

## QA vs QC
QC focuses more on detecting problems in made products, meanwhile QC focus on detecting problems before the products finished being developed.

![[Pasted image 20250715132610.png]]

![[Pasted image 20250715132333.png]]

## Test Artifacts
Artifacts in the thing being made in the testing process. 

I still doesn't understand what this graph means. 
- Test Strategy -> QA Lead -> QA Planning
- Test Plan -> QA Lead -> QA Planning
- Test Cases -> QA Tester -> Start of sprint
- Test Data -> QA Tester -> Start of sprint
- Requirement Traceability Matrix -> QA Tester -> Start of sprint
- Test Scripts -> QA Tester -> During testing
- Defect Reports -> QA Tester -> During testing
- Test Closure Report -> QA Lead -> After Testing
## Boundary Value Analysis
This is a testing techniques for **black-box** testing and focuses on the edges or boundaries of input data ranges. It is tested that way because most of the error happens in the boundary values rather than the middle values. 

Let's say we have constraints as:
1. Negative payment not allowed
2. Max limit is $ 2000
3. Debit card numbers should be numeric
4. Debit card number should have 16 digit

Then, based on that constraints, we could generate the boundary testing as such: 
Debit Card
- Test with alphabetic debit card number
- Test with blank debit card number
- Test with 1  digit debit card number
- Test with 15 digit debit card number
- Test with 16 digit debit card number
- Test with 17 digit debit card number

Payment
- Test with non numeric character for payment i.e., $ ABC
- Test with payment blank payment field
- Test with payment $ -1
- Test with payment $ 0
- Test with payment $ 1
- Test with payment $ 1000
- Test with payment $ 1999
- Test with payment $ 2000
- Test with payment $ 2001
## State Transition Testing
Another black-box testing. Testing the behavior of a system when it changes from one state to another in response to specific events or inputs. 

There are two main components in this types of testing. We usually use diagram for this.
- State
- Events

![[Screenshot 2025-07-15 at 13.40.37.png]]

For this diagram:
- State
	- Starting State
	- Blocked State
	- Logged in State
- Events
	- Incorrect PIN
	- Corrent PIn
	- Logout 
## Software Testing Life Cycle
QA is required at all stages, from conception to completion and maintenance.

![[Screenshot 2025-07-15 at 13.43.16.png]]

- Test design: turning the testing requirement into executable test plans.
- Environment setup: setting up the necessary hardware, software, and network to do the tests itself. 
## Priority vs Severity
From what I understand, the priority is dictated by how much the user will interact with the feature that has problem and the severity is dictated by how much the that broken feature will impact the business operation.

![[Pasted image 20250715135609.png]]
## Cost of Bugs
The later we found the bugs, the more expensive that the bugs will effect the company.

![[Pasted image 20250715135930.png]]
## When to stop testing

![[Pasted image 20250715140059.png]]

1. Whether all major positive and negative workflows are tested and working fine
2. Are there any Critical bugs left to fix
3. No. of bugs in last 2 cycles - Significant count decrease or not
4. Priority/Severity of bugs in last test cycle
5. Users appetite related to bugs
6. What is more costly - Going Live with some bugs vs Losing users to competitors if Not Going Live
## Defect Leakage
Explains how many bugs QA missed, which were observed by other persons in later stages.

Example scenario: 
QA Team completes testing and find 20 bugs in an application
UAT Team does its testing and find another 5 bugs in the same application
End User reports 2 issues on Production

Defect Leakage = 7
Defect Leakage percentage = 7 / (20+5+2) * 100 = 27%
## Defect Density
Defect density explains how much defects detected per 1000 lines of code (KLOC). This is used because usually, the more lines of code that the system has, the more defects it probably has.

Example scenario:
Consider following 3 modules of tiket app: Flight, Hotel and Train.
For simplicity consider all these 3 modules have 2K lines of code.
If we get 4 defects in Flight, 2 defects in Hotel and 8 defects in Train

So, it is clear that defect density of Train is highest, some calculation for reference below:

Defect density in Flight = 4 / 2000 = 2 defects per KLOC
Defect density in Hotel = 2 / 2000 = 1 defect per KLOC
Defect density in Train = 8 / 2000 = 4 defect per KLOC
## Defect Density Inference
We could get some idea based on where do we get the most defect density. We should always focus on the high defect density modules.

- High defect density may indicate problem in software development process
- High defect density in native apps may indicate incompatibility with latest OS
- High defect density in backend may indicate incompatibility with latest tech stack update (e.g., Java/SQL version, etc)


